---
title: Rust学习
date: 2024-02-26 16:04:09
permalink: /language/rust/3600d7/
categories:
  - 语言
  - Rust
tags:
  - Rust
  - Rust经验
  - 不器
  - 不器小窝
---

## 前言

本文是记录在 `Rust` 学习笔记，学完结束。

[Rust语言圣经(Rust Course)](https://course.rs)

`240305` 学习到了 `2.3.1` ，脑子被绕懵了，课后作业有一说一不错😂

<!-- more -->

<InArticleAdsense
    data-ad-client="ca-pub-1725717718088510"
    data-ad-slot="7426219401">
</InArticleAdsense>

## 浮点陷阱

1. 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
2. 浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你

注意：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

``` rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

输出

``` log
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

> 这是因为高精度进行加减的时候在小数点非常后的地方发生了微小的变化，导致了 `f64` 计算的结果和原始声明的结果出现了变化，断言失败


## `Range` (序列)

- 左闭右开
  
  `1...5`

- 左闭右闭

  `1...=5`

> 序列仅仅允许数字或者**字符（`char`）**类型，原因是他们可以连续

## `As` 类型转换

`Rust` 中可以使用 `As` 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。

## 如何引用第三方库

[Rust库中心 —— crates.io](https://crates.io/)

1. 使用 `cargo`

    ``` shell
    # xxx 为库名
    cargo add xxx
    ```

2. 操作 `Cargo.toml`

    在 `Cargo.toml` 中的 `[dependencies]` 下增加库名并指定版本
    ``` toml
    [dependencies]
    tauri = "1.6.0"
    ```

## 字符、布尔、单元类型

### 字符

`Rust` 中的字符类型代表一个 `Unicode`，`Unicode` 占用 `4` 个字节，所以在 `Rust` 中字符占用 `4` 个字节

### 布尔

`Rust` 中布尔值占用内存大小为 `1` 个字节

### 单元类型

`Rust` 中单元类型 `()` 可以用来占位，如果不注入值的话并不占据字节，即空的单元类型为 `0` 个字节

单元类型 `()` 是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的语句返回一个 `()`

## 语句和表达式

> **只有表达式能返回值**

### 语句和表达式的区别

- 初级理解
  - 表达式不能包含分号，必须要看结尾是否有 `;`
  - 是否在进行赋值(形态上看看就好)，如果没有 `;` 以上面的一条为主
  - 表达式总要返回值，如果没有返回值会隐式的返回一个单元类型 `()`
  - `macro` 是例外

> 中级理解还没达到那个能耐，等到达了再写吧

我在[`Rust` 联系实践](https://practice-zh.course.rs/basic-types/statements-expressions.html)中发现第一题的两种方式可以使其运行起来，但是有个疑惑点没有想通


``` rust
// eg1
fn main() {
    let v = {
        let mut x = 1;
        x += 2
    };
 
    assert_eq!(v, ());
}

// eg2
fn main() {
    let v = {
        let mut x = 1;
        x += 2;
        x
    };

    assert_eq!(v, 3);
}

// eg3
fn main() {
    let v = {
        let mut x = 1;
        x + 2;
    };

    assert_eq!(v, 3);
}
```

- 为什么在 `eg1` 中 `x += 2` 返回的是单元类型 `()`，而在 `eg2` 中返回的是 `i32` 类型

    **悟了**，这里面有个坑 `x += 2` 等价于 `x = x + 2` 所以这个表达式其实是一个赋值的代码，赋值的代码并不是一个变量数据，所以返回的是一个单元类型 `()`，所以我新增的 `eg3` 也是可以正常运行的

## 函数

### 函数要点

- 函数名和变量名使用蛇形命名法 `(snake case)` ，例如 `fn add_two() -> {}`
- 函数的位置可以随便放，`Rust` 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

注意：

- `Rust` 中只允许从函数体中使用 `return` 语句返回,而这里是一个代码块,只能使用表达式的值作为返回。
   
   ``` rust
    let v = {
        let mut x = 1;
        return x + 2; 
    };
   ```

- 永不返回的发散函数 `!`，当用 `!` 作函数返回类型的时候，表示该函数永不返回( `diverge function` )，特别的，这种语法往往用做会导致程序崩溃的函数

    ``` rust
    fn dead_end() -> ! {
        panic!("你已经到了穷途末路，崩溃吧！");
    }
    ```



### 匿名函数

#### 如何理解

1. 当匿名函数体内最后一个表达式没有分号时,该匿名函数会返回这个最后一个表达式的值。
2. 当最后一个表达式有分号或不存在时,该匿名函数会返回 `()` 单元类型。
3. 因为根据 `Rust` 的规则,默认返回 `()`。

## 所有权和借用

### 所有权

#### 所有权原则

1. `Rust` 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. **一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者**
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(`drop`)

#### 栈(`Stack`)与堆(`Heap`)

> 栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间

##### 栈(`Stack`)

- 栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**、**先进后出**
- 增加数据叫做**进栈**，移出数据则叫做**出栈**
- 栈中的所有数据都**必须**占用已知且固定大小的内存空间

::: note
想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！
:::

##### 堆(`Heap`)

> 对于大小未知或者可能变化的数据，将它存储在堆上

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”(`allocating`)，然后该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据

我个人的理解就是书籍的目录「栈」对应页码，然后寻找具体章节「堆」的过程

##### 性能区别

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

##### 所有权与堆栈

当代码调用的某一个函数的时候，传递的参数会被依次压入栈中，当函数执行完毕后这些参数会按照**后进先出**的原则依次移除

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 `Rust` 所有权系统为我们提供的强大保障。在 `Rust` 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助

**当所有权转移时，可变性也可以随之改变**，也就是说新的变量拥有所有权的时候它是不可变的，如果要进行改变需要加上 `mut` 关键字

> 我想到一个情况，如果按这个逻辑来看的话，那么在写 `rust` 代码时传递参数时，是否需要让容量比较高的参数放在后面，使其在删除的时候更早的删除

::: warning
如何声明一个 `String` 类型的变量
``` rust
let s ="hello" // s 是一个指向字符串的指针，类型是 &str
let s = String::from("hello"); // s 是一个指向字符串的指针，类型是 String
```

> `::` 是一种调用操作符，这里表示调用 `String` 模块中的 `from` 方法，由于 `String` 类型存储在堆上，因此它是动态的
:::

### 变量绑定背后的数据交互

> 注意：基本类型是存储在「栈」上的，而复杂类型是存储在「堆」上的
> 基本的数据类型有：
>  1. 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
>  2. 字符串：字符串字面量和字符串切片 `&str`
>  3. 布尔类型： `true` 和 `false`
>  4. 字符类型: 表示单个 `Unicode` 字符，存储为 4 个字节
>  5. 单元类型: 即 `()` ，其唯一的值也是 `()`

> 注意：
> 当变量离开作用域的时候 `Rust` 会自动调用 `drop` 来清理变量的堆内存。如果两个变量指向到了同一个位置的话，那么这个时候就会陷入一个问题，因为 `Rust` 会调用两次 `drop`，这样就会导致程序崩溃，所以 `Rust` 会自动调用 `drop` 的时候会将变量的所有权转移给另一个变量，这样就不会出现两次 `drop` 的问题。这样的情况叫做：二次释放（`double free`）

#### 实战解说

``` rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}",s1);
```

上面的代码中，`s1` 赋值给了 `s2` 后，`Rust` 就认为 `s1` 不再有效，因此在 `s1` 离开作用域的时候 `Rust` 不会 `drop` 任何东西。如果这时候要对 `s1` 进行操作的时候就会提示 `borrow of moved value: 's1'`，这是因为 `s1` 已经不再有效了，`Rust` 禁止使用无效的引用。

但是，下面的代码是可以正常运行的，原因是 `s2` 是 `s1` 的一个引用，所以 `s2` 的值是 `s1` 的一个引用，所以 `s1` 离开作用域的时候 `Rust` 不会 `drop` 任何东西

我个人理解的是基础类型数据是存储在栈上的，所以 `s1` 在赋值给 `s2` 的时候实际上是使用了一次拷贝的过程，直接将整个数据给了一份给 `s2` 在栈上创建了。

``` rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

**任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**

可以 `Copy` 的类型:

- 所有整数类型
- 布尔类型
- 所有浮点数类型
- 字符类型
- 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，(`i32`, `i32`) 是 Copy 的，但 (`i32`, `String`) 就不是
- 不可变引用 &T，**但是注意: 可变引用 `&mut T` 是不可以 `Copy` 的**

> 所以我简单的理解为 凡是以上类型进行赋值的行为可以认为是在进行 `Copy` 操作

### 引用与借用

#### 引用与解引用

常规引用是一个指针类型，指向了对象存储的内存地址，也就是使用 `&` 符号来创建一个引用，这个引用是不可变的，也就是说不能修改引用的值，但是可以修改引用的指向。

必须使用 `*y` 来解出引用所指向的值（也就是**解引用**）

``` rust
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
```

#### 不可变引用

`&` 符号即是引用，它们允许你使用值，但是不获取所有权，也就是新的变量离开作用域的时候这个引用即失效，但原始的数据不会 `drop`

``` rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

#### 可变引用

如果要在 `calculate_length` 函数中改变 `s` 的值操作如下

``` rust
fn main() {
    let mut s1 = String::from("hello");

    let len = calculate_length(&mut s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &mut String) -> usize {
    s.push_str(",word");
    s.len()
}
```

> 注意：
> 1. **可变引用同时只能存在一个**
> 2. **同一作用域，特定数据只能有一个可变引用**

我理解的是，当 `a` 被声明可变变量(`mut`)时，`b` 进行可变引用这个时候是**允许**的，但是**同时** `c` 也进行了可变引用，这时候是**不允许**的

`Rust` 在编译初期就会进行上面的检查，即 `borrow checker`，该检查的好处：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制
- 减少后期在运行时出现数据交叉的问题

如果一定要在一个函数中对某个变量进行多次可变引用的话，可以使用大括号来对上一个可变引用进行作用域的限制

#### 可变引用与不可变引用不能同时存在

``` rust
    let a = String::from("hello");
    let b = &a;
    let c = &a;
    let d = &mut a; // 这里在编译器中直接就会报错，提示'无法借用不可变局部变量 `a` 作为可变变量'
    println!("{}",d);
```

这就相当于你把车借给你的朋友开，结果你的朋友又借给他的朋友，这时候你朋友的朋友借走了，他想把车改一改，这时候作为车主的你肯定是不会愿意的

如果你想让 `d` 能够使用 `a` 的值并作出改变的话，那么这时候你需要使用 `clone`

``` rust
let a = String::from("hello");
let b = &a;
let c = &a;
let d = a.clone();
println!("{}",d);
```

`ref` 与 `&` 类似，可以用来获取一个值的引用，但是它们的用法有所不同。通常情况下是直接将变量赋值的时候发现需要进行引用时使用 `ref`

``` Rust
    let c = '中';

    let r1 = &c;
    // 填写空白处，但是不要修改其它行的代码
    let ref r2 = c;

    assert_eq!(*r1, *r2);
```

> `Rust` 是通过 `NLL(Non-Lexical Lifetimes)` 来进行编译器的优化

#### 垂直引用(`Dangling References`)

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 `Rust` 中编译器可以确保引用**永远也不会变成悬垂状态**：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

``` rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

上面这段代码在 `dangle` 函数中返回了指针地址，但是因为 `dangle` 函数结束了，导致 `s` 这个变量要被销毁，所以编辑器直接会提示「缺少生命周期说明符」，即代码进行了垂直引用

### 借用规则总结

- 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
- 引用必须总是有效的

## 复合类型

> 如果在 `Rust` 代码中存在声明后未使用的，那么需要进行「**编译器属性标记**」，即引入 `#![allow(unused_variables)]`

### 切片

创建切片的语法，使用方括号包括的一个序列：**[开始索引..终止索引]**

``` Rust
let empty_silce_i32: &[i32] = &[];
let empty_silce_str: &[String] = &[];
```

取值：



``` Rust
let s = String::from("hello");
// 获取字符串s的前两位
let slice = &s[0..2];
let slice = &s[..2]; // 等效上一行的写法

// 获取字符串的第四位到最后一位
let slice = &s[4..len];
let slice = &s[4..]; // 等效上一行的写法

// 获取完整的字符串
let len = s.len();
let slice = &s[0..len];
let slice = &s[..]; // 等效上两行的写法
```

> 注意：
> `Rust` 在提取中文的时候要注意一个中文占三个字节，如何操作请看[这里](###切片) //todo

``` Rust
    let s = "中国人";
    println!("{}",s.len());
    // 输出 9
```

**字符串切片的类型标识是 `&str`**，所以函数在返回切片时可以直接返回 `&str`

#### 字符串字面量是切片

`let a = "Hello, world!";` `a` 的实际类型是 `&str`

**`Rust` 中的字符是 `Unicode` 类型，因此每个字符占据 `4` 个字节内存空间，但是在字符串中不一样，字符串是 `UTF-8` 编码，也就是字符串中的字符所占的字节数是变化的(`1 - 4`)**

`Rust` 在语言级别，只有一种字符串类型： `str`，它通常是以引用类型出现 `&str`，也就是上文提到的字符串切片。所以在 `Rust` 中提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 `UTF-8` 编码

##### `String` 与 `&str` 的转换

`String` 转 `&str`

``` Rust
let a = String::from("hello world");
// 或
let a = "hello world".to_string();
```

`&str` 转 `String`

``` Rust
let s = String::from("hello,world!");

```
