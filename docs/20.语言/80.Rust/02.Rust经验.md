---
title: Rust经验
date: 2024-02-26 16:04:09
permalink: /language/rust/3600d7/
categories:
  - 语言
  - Rust
tags:
  - Rust
  - Rust经验
  - 不器
  - 不器小窝
---

## 前言

本文是记录在 `Rust` 学习中遇到的一些小经验，持续更新。

<!-- more -->

<InArticleAdsense
    data-ad-client="ca-pub-1725717718088510"
    data-ad-slot="7426219401">
</InArticleAdsense>

## 浮点陷阱

1. 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
2. 浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你

注意：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

``` rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

输出

``` log
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

> 这是因为高精度进行加减的时候在小数点非常后的地方发生了微小的变化，导致了 `f64` 计算的结果和原始声明的结果出现了变化，断言失败


## `Range` (序列)

- 左闭右开
  
  `1...5`

- 左闭右闭

  `1...=5`

> 序列仅仅允许数字或者**字符（`char`）**类型，原因是他们可以连续

## `As` 类型转换

`Rust` 中可以使用 `As` 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。

## 如何引用第三方库

[Rust库中心 —— crates.io](https://crates.io/)

1. 使用 `cargo`

    ``` shell
    # xxx 为库名
    cargo add xxx
    ```

2. 操作 `Cargo.toml`

    在 `Cargo.toml` 中的 `[dependencies]` 下增加库名并指定版本
    ``` toml
    [dependencies]
    tauri = "1.6.0"
    ```

## 字符、布尔、单元类型

### 字符

`Rust` 中的字符类型代表一个 `Unicode`，`Unicode` 占用 `4` 个字节，所以在 `Rust` 中字符占用 `4` 个字节

### 布尔

`Rust` 中布尔值占用内存大小为 `1` 个字节

### 单元类型

`Rust` 中单元类型 `()` 可以用来占位，如果不注入值的话并不占据字节，即空的单元类型为 `0` 个字节

## 语句和表达式

### 语句和表达式的区别

- 初级理解
  - 表达式不能包含分号，必须要看结尾是否有 `;`
  - 是否在进行赋值(形态上看看就好)，如果没有 `;` 以上面的一条为主
  - 表达式总要返回值，如果没有返回值会隐式的返回一个单元类型 `()`
  - `macro` 是例外

> 中级理解还没达到那个能耐，等到达了再写吧

我在[`Rust` 联系实践](https://practice-zh.course.rs/basic-types/statements-expressions.html)中发现第一题的两种方式可以使其运行起来，但是有个疑惑点没有想通


``` rust
// eg1
fn main() {
    let v = {
        let mut x = 1;
        x += 2
    };
 
    assert_eq!(v, ());
}

// eg2
fn main() {
    let v = {
        let mut x = 1;
        x += 2;
        x
    };

    assert_eq!(v, 3);
}

// eg3
fn main() {
    let v = {
        let mut x = 1;
        x + 2;
    };

    assert_eq!(v, 3);
}
```

- 为什么在 `eg1` 中 `x += 2` 返回的是单元类型 `()`，而在 `eg2` 中返回的是 `i32` 类型

    悟了，这里面有个坑 `x += 2` 等价于 `x = x + 2` 所以这个表达式其实是一个赋值的代码，赋值的代码并不是一个变量数据，所以返回的是一个单元类型 `()`，所以我新增的 `eg3` 也是可以正常运行的

## 匿名函数

### 理解

1. 当匿名函数体内最后一个表达式没有分号时,该匿名函数会返回这个最后一个表达式的值。
2. 当最后一个表达式有分号或不存在时,该匿名函数会返回 `()` 单元类型。
3. 因为根据 `Rust` 的规则,默认返回 `()`。
