---
title: 用户中心后端-4
date: 2025-04-03 11:25:50
permalink: /projects/df37ab/
categories:
  - 项目
  - 用户中心系统
tags:
  - 用户中心系统
---


# 06.用户中心后端-4

后端部分的登录功能

<!-- more -->   

## 功能：用户登录

### 详细设计

**登录接口**

1. 接收参数：用户账户、密码
2. 请求类型：POST
3. 请求体：JSON格式的数据
4. 返回值：用户信息

**逻辑**

1. 检验用户账户和密码是否合法
   - 账户和密码不能是空
   - 账户不小于4位
   - 密码不小于8位
   - 账户不包含特殊字符
2. 检验密码是否输入正确，与数据库中的密文密码对比
3. 用户脱敏，隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端SpringBoot框架封装的服务器tomcat去记录）
   - cookie
5. 返回安全脱敏的用户信息



**编写代码**

1. 在`UserService`编写登录代码，写如下代码，Alt+Enter实现方法![image-20250403113709636](../../.vuepress/public/blog_images/image-20250403113709636.png)

接下来我们要实现加密

### md5加密&盐值

（一）MD5摘要算法：

- MD5信息摘要算法广泛使用的密码散列函数
- MD5可以产生一个128位的散列值用于唯一标识源数据
- 项目中通常使用MD5作为敏感数据的加密算法

（二）特点：

- 压缩性，MD5生成的摘要长度固定
- 抗修改性，源数据哪怕有一个字节变化，MD5也会有巨大差异
- 不可逆，无法通过MD5反向推算源数据
- 计算速度快

MD5的加密也会在某些情景下变得易破解

**彩虹表：**由于MD5的计算速度很快，攻击者可以预先计算出大量常见密码的MD5值，形成彩虹表，用于快速破解密码。

**碰撞攻击：**存在不同的输入数据生成相同哈希值的可能性

MD5对应的加密之后的信息能够通过**彩虹表**得到解密，这让数据并不够安全，那怎么办呢？

（三）MD5+盐值

混淆加密，例如我们最初想要加密的字符串是test

我们在加密的时候可以给test加点“盐”

例如我们通过这个简单的算法：

```java
public static String md5Digest(String source,Integer salt){
    //source:需要加密的原始字符串。 salt：一个整数值，用于逐字符加盐。
        char[] ca=source.toCharArray();//将source转化为字符数组
        for(int i=0;i<ca.length;i++){
            ca[i]=(char)(ca[i]+salt);//给每个字符加上盐值
        }
        String target=new String(ca);//重新组合字符串变成target
        String md5=DigestUtils.md5Hex(target);//进行MD5加密
        return md5;
    }
```

这样就完成了md5+盐值混淆之后的数据

### **加密功能**

final是java的一种关键词，用于修饰内容表示其不可变。

将表示盐值的变量`private static final String SALT = "yupi";`

写在类的里面，方法的前面

<img src="../../.vuepress/public/blog_images/image-20250403204424008.png" alt="image-20250403204424008" style="zoom: 33%;" />

**注解 @Slf4j**

在类前加一个@Slf4j注解![image-20250403205400407](../../.vuepress/public/blog_images/image-20250403205400407.png)

@Slf4j 是 Lombok 提供的一种注解，用于在类中自动生成一个名为 log 的日志对象。通过使用 @Slf4j 注解，可以方便地在代码中使用日志功能，而无需手动创建和初始化日志对象。

注解示例：

```java
 @Slf4j
 public class LogExample {
 }
```

在上述示例中，LogExample类被标记为使用 `@Slf4j` 注解，它将自动创建一个名为 `log` 的日志对象。

可见lombok的官方文档：[Slf4j (Lombok)](https://projectlombok.org/api/lombok/extern/slf4j/Slf4j)

### 逻辑编写

可以从注册功能把代码搬过来修改，主要是去掉了checkPassword

和注册不同的是，这里返回的是null，有不完美的地方，不能反馈具体的错误码

```java
    @Override
    public User doLogin(String userAccount, String userPassword) {
        /* 1.检验 */
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;//空白
        }
        if (userAccount.length() < 4){
            return null;
        }
        if (userPassword.length() < 8 ){
            return null;
        }

        //账户不能包含特殊字符
        String vaildateRegExp = "[^a-zA-Z0-9]";
        Matcher matcher = Pattern.compile(vaildateRegExp).matcher(userAccount);
        if (matcher.find()){
            return null;
        }

        /* 2.加密 */
        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());
        //账户不能重复
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", encryptPassword);
        User user = userMapper.selectOne(queryWrapper);
        if (user == null){
            log.info("[UserCenter]User login failed,userAccount cannot match userPassword");
            return null;
        }
    return user;
    }
```

上面查询用户是否存在的功能存在问题，因为我们设置了isDelete属性，`0`表示存在状态，`1`表示删除状态，这是一种叫做逻辑删除的数据管理方法

> 通过在数据库中标记记录为“已删除”而非物理删除，来保留数据的历史痕迹，同时确保查询结果的整洁性。

在MyBatis-Plus中提供了此支持

[逻辑删除支持 | MyBatis-Plus](https://baomidou.com/guides/logic-delete/#步骤-1-配置全局逻辑删除属性)

MyBatis-Plus 的逻辑删除功能会在执行数据库操作时自动处理逻辑删除字段。以下是它的工作方式：

- **插入**：逻辑删除字段的值不受限制。
- **查找**：自动添加条件，过滤掉标记为已删除的记录。
- **更新**：防止更新已删除的记录。
- **删除**：将删除操作转换为更新操作，标记记录为已删除。

例如：

- **删除**：`update user set deleted=1 where id = 1 and deleted=0`
- **查找**：`select id,name,deleted from user where deleted=0`

**配置**：

1.在 `application.yml` 中配置 MyBatis-Plus 的全局逻辑删除属性：

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除字段名
      logic-delete-value: 1 # 逻辑已删除值
      logic-not-delete-value: 0 # 逻辑未删除值
```

2.在User实体类中使用 `@TableLogic` 注解

```java
import com.baomidou.mybatisplus.annotation.TableLogic;

public class User {
    // 其他字段...

    @TableLogic
    private Integer isDelete;
}
```

*文字写于：广东*